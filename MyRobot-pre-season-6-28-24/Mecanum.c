#pragma config(Hubs,  S2, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     Lrear,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     Lfront,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     Rfront,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     Rrear,         tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

long map(long x, long in_min, long in_max, long out_min, long out_max)// used to handle the scaling of ranges// borrowed from arduino.cc
{
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

task main()
{
	while(true)
	{
		int x = joystick.joy1_x1;
		int y = joystick.joy1_y1;
		int z = joystick.joy1_x2;
		// calculate wheel throttles
		int Lf =	 x + y + z;// +/- (127+127+127)
		int Rf =	 x - y + z;
		int Lr =	-x + y + z;
		int Rr =	-x - y + z;
		// max of +/- (380)

		//scale the values above to create more accurate motor control.
		int Lfs = map(Lf, -380,380,-100,100);
		int Lrs = map(Lr, -380,380,-100,100);
		int Rfs = map(Rf, -380,380,-100,100);
		int Rrs = map(Rr, -380,380,-100,100);

/* //*****************************************************************************************************************************
		//write output to the debug stream for troubleshooting
		writeDebugStreamLine("LFS:%i",Lfs);
		writeDebugStreamLine("LRS:%i",Lrs);
		writeDebugStreamLine("RFS:%i",Rfs);
		writeDebugStreamLine("RRS:%i",Rrs);

		// assign the values to the motors...
		motor[Lfront] =Lfs;
		motor[Lrear]	=Lrs;
		motor[Rfront] =Rfs;
		motor[Rrear]	=Rrs;
// the above works but leaves a lot more motor creep than desired; due to joystick innacuracy. I've tried something different below.
*/ //******************************************************************************************************************************


		// normalize the values and set a threshold so the motors will not creep.
		const static int threshold =8; // Int 'threshold' will allow us to ignore low	readings that keep our robot in perpetual motion.
		// Lfs controlled by ignoring low readings
		if(abs(Lfs)>threshold)
		{
			motor[Lfront] =Lfs;
		}
		else
		{
			motor[Lfront] =0;
		}
		// Lrs controlled by ignoring low readings
		if(abs(Lrs)>threshold)
		{
			motor[Lrear]	=Lrs;
		}
		else
		{
			motor[Lrear]	=0;
		}
		// Rfs controlled by ignoring low readings
		if(abs(Rfs)>threshold)
		{
			motor[Rfront] =Rfs;
		}
		else
		{
			motor[Rfront] =0;
		}
		// Rrs controlled by ignoring low readings
		if(abs(Rrs)>threshold)
		{
			motor[Rrear]	=Rrs;
		}
		else
		{
			motor[Rrear]	=0;
		}
		writeDebugStreamLine(" Lfs:%i \n Lrs:%i \n Rfs:%i \n Rrs:%i \n",Lfs,Lrs,Rfs,Rrs);// write output to the debug stream
	}
}
