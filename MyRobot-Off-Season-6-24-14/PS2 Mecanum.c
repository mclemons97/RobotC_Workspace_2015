#pragma config(Hubs,	S2, HTMotor,	HTMotor,	none,			none)
#pragma config(Sensor, S1,		 ,							 sensorI2CMuxController)
#pragma config(Sensor, S2,		 PSPNX,					 sensorI2CCustomFastSkipStates)
#pragma config(Motor,	 motorA,					 ,						 tmotorNXT, openLoop)
#pragma config(Motor,	 motorB,					 ,						 tmotorNXT, openLoop)
#pragma config(Motor,	 motorC,					 ,						 tmotorNXT, openLoop)
#pragma config(Motor,	 mtr_S1_C1_1,			Rrear,				 tmotorTetrix, openLoop)
#pragma config(Motor,	 mtr_S1_C1_2,			Rfront,				 tmotorTetrix, openLoop)
#pragma config(Motor,	 mtr_S1_C2_1,			Lrear,				 tmotorTetrix, openLoop)
#pragma config(Motor,	 mtr_S1_C2_2,			Lfront,				 tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//

#include "PS2/includes/PSP-Nx-lib.h"
const ubyte Addr = 0x02;
long map(long x, long in_min, long in_max, long out_min, long out_max);

task main()
{
	psp cuRrState;
	nI2CBytesReady[PSPNX] = 0;
	PlaySound(soundUpwardTones);

	while(true)
	{
		/*user code below*/
		PSP_ReadButtonState(PSPNX, Addr, cuRrState);
		bool joystick_joy1_btn_1			= !(char)cuRrState.square;//unused true or false
		bool joystick_joy1_btn_2			= !(char)cuRrState.cross; //unused
		bool joystick_joy1_btn_3			= !(char)cuRrState.circle;//unused
		bool joystick_joy1_btn_4			= !(char)cuRrState.triang;//unused
		bool joystick_joy1_Dpad_Up		= !(char)cuRrState.d;			//unused
		bool joystick_joy1_Dpad_Right = !(char)cuRrState.c;			//unused
		bool joystick_joy1_Dpad_Down	= !(char)cuRrState.b;			//unused
		bool joystick_joy1_Dpad_Left	= !(char)cuRrState.a;			//unused
		bool joystick_joy1_L_Bumper		= !(char)cuRrState.l1;		//unused
		bool joystick_joy1_R_Bumper		= !(char)cuRrState.r1;		//unused
		bool joystick_joy1_L_Trigger	= !(char)cuRrState.l2;		//unused
		bool joystick_joy1_R_Trigger	= !(char)cuRrState.r2;		//unused
		bool joystick_joy1_btn_13			= !(char)cuRrState.l_j_b; //unused
		bool joystick_joy1_btn_14			= !(char)cuRrState.r_j_b; //unused
		int joystick_joy1_x1					= (int)cuRrState.l_j_x;		//(-100)-(100)
		int joystick_joy1_y1					= (int)cuRrState.l_j_y;		//(-100)-(100)
		int joystick_joy1_x2					= (int)cuRrState.r_j_x;		//(-100)-(100)
		int joystick_joy1_y2					= (int)cuRrState.r_j_y;		//unused (-100)-(100)


		int x = joystick_joy1_x1;
		int y =-joystick_joy1_y1;
		int z = joystick_joy1_x2;
		// calculate wheel throttles
		int Lf =	 x + y + z;
		int Rf =	 x - y + z;
		int Lr =	-x + y + z;
		int Rr =	-x - y + z;
		// max of +/-(300)
		//scale the values above to create more accurate motor control.
		int Lfs = 3* map(Lf, -300,300,-100,100);
		int Lrs = 3* map(Lr, -300,300,-100,100);
		int Rfs = 3* map(Rf, -300,300,-100,100);
		int Rrs = 3* map(Rr, -300,300,-100,100);
		//writeDebugStreamLine("LFS:%i",Lfs);
		//writeDebugStreamLine("LRS:%i",Lrs);
		//writeDebugStreamLine("RFS:%i",Rfs);
		//writeDebugStreamLine("RRS:%i",Rrs);
		// assign the values to the motors...
		/*
		motor[Lfront] =Lfs;
		motor[Lrear]	=Lrs;
		motor[Rfront] =Rfs;
		motor[Rrear]	=Rrs;
		*/
		// the above works but leaves a lot of creep so ive comented it out and tried something different below.

		// normalize the values and set a threshold so the motors will not creep.
		const static int threshold =14; // Int 'threshold' will allow us to ignore low	readings that keep our robot in perpetual motion.
		// Lfs controlled by ignoring low readings
		if(abs(Lfs)>threshold)
		{
			motor[Lfront] =Lfs;
		}
		else
		{
			motor[Lfront] =0;
		}
		// Lrs controlled by ignoring low readings
		if(abs(Lrs)>threshold)
		{
			motor[Lrear]	=Lrs;
		}
		else
		{
			motor[Lrear]	=0;
		}
		// Rfs controlled by ignoring low readings
		if(abs(Rfs)>threshold)
		{
			motor[Rfront] =Rfs;
		}
		else
		{
			motor[Rfront] =0;
		}
		// Rrs controlled by ignoring low readings
		if(abs(Rrs)>threshold)
		{
			motor[Rrear]	=Rrs;
		}
		else
		{
			motor[Rrear]	=0;
		}
		writeDebugStreamLine(" Lfs :%i, Lrs :%i, Rfs:%i, Rrs:%i",Lfs,Lrs,Rfs,Rrs);// debug
		wait10Msec(5);
	}
}

//vector functions for autonomous and debuging
void forward(int magnitude)
{
	motor[Rfront]= magnitude;
	motor[Rrear] = magnitude;
	motor[Lfront]= -magnitude;
	motor[Lrear] = -magnitude;
}
void reverse(int magnitude)
{
	motor[Rfront]= -magnitude;
	motor[Rrear] = -magnitude;
	motor[Lfront]= magnitude;
	motor[Lrear] = magnitude;
}
void left(int magnitude)
{
	motor[Rfront]= -magnitude;
	motor[Rrear] = magnitude;
	motor[Lfront]= -magnitude;
	motor[Lrear] = magnitude;
}
void right(int magnitude)
{
	motor[Rfront]= magnitude;
	motor[Rrear] = -magnitude;
	motor[Lfront]= magnitude;
	motor[Lrear] = -magnitude;
}
// definition of map. (used for scaling values)
long map(long x, long in_min, long in_max, long out_min, long out_max)
{
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}
